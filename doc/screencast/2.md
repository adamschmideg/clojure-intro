# Clojure basics
(See also http://www.cis.upenn.edu/~matuszek/Concise%20Guides/Concise%20Clojure.html)

    => ; Data
    => 42
    => 0.3333333
    => 1/3
    => "some text"
    => :keyword
    => true
    => false
    => nil
    => [1 2 4]
    => ["mixed vector" :of 4 "entries"]
    => {:eyes 2, :fingers 20}
    => {:lucky-numbers [3 7 9], :unlucky-numbers [4 13]}
    => #{:set :of :keywords :of :keywords}
    => #"regex.*"
    => #"("
    => (def pi 3.14)
    => pi
    => (def xs [2 3 5 8])
    => xs
    => (let [local-pi pi] local-pi)
    => (let [pi 3] pi)
    => pi
    => (let [local-pi 3
             pi local-pi]
         pi)
    => pi

    => ; Call a function: (function arg1 arg2 ...)
    => (- 5 3)
    => (max 0 (min 1 2))
    => (= 3 4)
    => (= {:eyes 2, :fingers 20} {:fingers 20, :eyes 2})
    => (if true :truthy :FALSEY)
    => (if false :truthy :FALSEY)
    => (if nil :truthy :FALSEY)
    => (if :anything-else :truthy :FALSEY)
    => (if 42 :truthy :FALSEY)
    => (if 0 :truthy :FALSEY)
    => (if [] :truthy :FALSEY)
    => (if {} :truthy :FALSEY)
    => (when true :truthy)
    => (when false :truthy)
    => (when nil :truthy)
    => xs
    => (first xs)
    => (rest xs)
    => (count xs)
    => (reverse xs)
    => (take 2 xs)
    => (drop 2 xs)
    => (filter odd? xs)
    => (remove odd? xs)
    => (every pos? xs)
    => (some even? xs)
    => (map inc xs)
    => (apply max xs)
    => (reduce + [1 2 3])

    => ; lambda 
    => (fn [x] (+ x 1))
    => ((fn [x] (+ x 1)) 42)
    => (map (fn [x] (+ x 1)) [2 4])
    => (def inc' (fn [x] (+ x 1)))
    => (inc' 42)
    => (map inc' [2 4])
    => (defn inc-simpler [x] (+ x 1))
    => (inc-simpler 42)
    => (defn avg [x y] (/ (+ x y) 2))
    => avg
    => (avg 3 5)
    => (avg 3 5 1)
    => (defn avg [& rest-args] (/ (reduce + rest-args) (count rest-args))) 
    => (avg 3 5 1)

    => ; deep structures
    => (def me {:eyes 2, :fingers 20, :name {:first "Jack"}, :numbers [7 13]})
    => (get me :eyes)
    => (get me :tail)
    => (get me :tail :invisible)
    => (me :eyes)
    => (get me :name)
    => (get-in me [:name :first])
    => (get-in me [:tail :no-NPE])
    => (get-in me [:numbers 0])
    => (get-in me [:numbers 2])
    => (-> me :name)
    => (-> me :name :first)
    => (-> me :name :first first)
    => (-> me :fingers inc)
    => (-> me :fingers (- 2))
    => (assoc me :nose 1)
    => (assoc me :name "Jack the Ripper")
    => (assoc-in me [:name :family] "the Ripper")
    => (assoc-in me [:name :family] "the Ripper")
    => (assoc-in me [:name first] "Jack")

    => ; namespaces
    => (def x 42)
    => x
    => (ns foo.bar)
    => x
    => (def x 999)
    => (ns user)
    => x
    => (ns foo.bar (:require [clojure.string :as string]))
    => (string/trim "  abc\n  ")
    => (string/upper-case "abc")
    => (string/split "jack, mary, john" #", *")
    => (-> "  bookkeeper  " string/trim string/upper-case (string/split #"E+"))
    => union
    => (ns foo.bar (:use clojure.set))
    => union
    => (union #{3 4} #{4 5})
    => (ns foo.bar (:use [clojure.data :only [diff]]))
    => (diff #{3 4 5} #{4 5 6})
